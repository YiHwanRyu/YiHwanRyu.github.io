---
layout: single
title: "TIL068: 자바스크립트 필요 개념정리(16)"
categories: [TIL]
tag: [TIL, Javascript, 모던 자바스크립트 Deep Dive]
toc: true
toc_sticky: true
toc_label: 목차
toc_icon: "fas fa-mug-hot"
author_profile: false
search: true
use_math: true
published: true
sidebar:
  nav: "counts"
---

# [부제: this, 실행 컨텍스트]
Today I Learned, 2024/03/15

## ◆ 내용정리
- '모던 자바스크립트 Deep Dive' 도서를 공부하면서 필요한 내용을 정리하였음.
- 관련 출처는 문서 아래의 '참고링크'에 기재함.

### '모던 자바스크립트 Deep Dive'의 22 - 23장 중 내용 정리

#### 1) this
- 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
  - this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.
- this 바인딩(this가 가리킬 객체를 바인딩 하는 것)은 함수 호출 방식에 의해 호출 시점에 동적으로 결정된다.
  - 일반적으로 this는 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. 일반 함수 내부나 전역에서 사용할 일이 거의 없음.
    - 일반함수로 호출된 함수의 내부: this는 전역 객체를 가리킴, 중첩 함수, 콜백 함수도 마찬가지. 하지만 strict mode에서는 undefined가 바인딩된다.
    - 객체의 메서드 내부: this는 메서드를 호출한 객체를 가리킴
    - 생성자 함수 내부: this는 생성자 함수가 (미래에) 생성할 인스턴스를 가리킴.
- 따라서 this의 바인딩을 일치시킬 필요가 있음.
  - 클로저 개념, 화살표 함수(상위 스코프의 this를 가리킴), Function.prototype.apply/call/bind에 의한 간접호출 방법 존재.
  - 코드 예시 및 설명

    {% raw %}
    ```javascript
    showYourThis = function () {
      console.log(arguments);
      return this;
    };

    const obj = {
      prop: 'a',
      objMethod(callback) {
        setTimeout(callback, 100);
      },
    };

    // console.log(showYourThis()); // Object [global]

    // Function.prototype.apply: 함수를 호출함
    // 두번째 인수로 배열을 넘길 수 있음(호출할 함수의 인수로 사용)
    console.log(showYourThis.apply(obj, [0, 1, 5]));
    // [Arguments] { '0': 0, '1': 1, '2': 5 }
    // { prop: 'a', objMethod: [Function: objMethod] }

    // Function.prototype.call: 함수를 호출함
    // 두번째 인수로 쉼표 구분 리스트를 넘김(호출할 함수의 인수로 사용)
    console.log(showYourThis.call(obj, 0, 1, 5));
    // [Arguments] { '0': 0, '1': 1, '2': 5 }
    // { prop: 'a', objMethod: [Function: objMethod] }

    // Function.prototype.bind: 바인딩 교체함수 반환
    // 중첩함수도 전역객체가 바인딩 된다. 따라서 global.prop은 없으므로 undefined
    obj.objMethod(function () {
      console.log(this.prop); // undefined
    });

    const obj2 = {
      prop: 'a',
      obj2Method(callback) {
        setTimeout(callback.bind(this), 100); // bind() 활용
      },
    };

    obj2.obj2Method(function () {
      console.log(this.prop); // a, bind로 obj2가 this가 되어 obj2.a 출력
    });

    ```
    {% endraw %}


#### 2) 실행 컨텍스트
- 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
- 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택(콜스택)으로 관리한다.
  - 렉시컬 환경: 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
    - 스코프를 구분하여 식별자를 등록하고 관리하는 렉시컬 스코프의 실체이다.
  - 실행 컨텍스트: 실행 컨텍스트 스택(콜스택)에 담기는 정보, 소스코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역 
    - LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트로 구성.  
      - 초기에 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트는 같은 렉시컬 환경을 참조한다.
      - 추후에 VariableEnvironment 컴포넌트는 변경사항을 실시간으로 반영함.
      - 간단하게 두 컴포넌트를 LexicalEnvironment 하나로 통일하여 설명할수도 있다.
    - 두 컴포넌트를 렉시컬 환경으로 통일하면, 렉시컬 환경은 다음과 같은 두 개의 컴포넌트로 구성됨.
      - 환경 레코드(Environment Record)
        - 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소. 
        - 소스코드 타입에 따라 관리하는 내용에 차이가 있다.
      - 외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)
        - 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킴. 
        - 상위 스코프: 외부 렉시컬 환경, 해당 컨텍스트를 생성한 소스코드를 포함하는 상위코드의 렉시컬 환경
        - 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을 구현함.


#### 3) 실행 컨텍스트 생성과 식별자 검색 순서 정리
- (1) 전역 객체 생성
  - 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체가 추가되며 동적 환경에 따라 클라이언트 사이드 Web API 또는 호스트 객체가 포함됨.
  - 전역 객체도 Object.prototype을 상속 받으므로 프로토타입 체인의 일원임.
- (2) 전역 코드 평가
  - (2-1) 전역 실행 컨텍스트 생성
    - 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택(콜스택)에 푸시함. 이때, 전역 실행 컨텍스트는 실행중인 실행 컨텍스트가 된다.
  - (2-2) 전역 렉시컬 환경 생성: 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩함.
    - 전역 환경 레코드 생성
      - ES6 이전에는 모든 전역 변수가 전역 객체의 프로퍼티가 되었기 때문에 전역 객체가 전역 환경 레코드의 역할을 수행했었음.
      - 하지만 let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재함.
      - 따라서, 두 경우를 구분하여 관리하기 위해 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성됨.
        - 객체 환경 레코드 생성
          - 전역 객체 생성 시 생성된 BindingObject와 연결된다.
          - var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수는 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.
            - 따라서 var 키워드 선언 변수는 코드 실행 단계에서 변수 선언문 이전에도 참조 할 수 있다.(undefined), 변수 호이스팅이 발생하는 원인. 
            - 또한, 함수 선언문으로 정의된 함수도 동일한 이름의 식별자를 BindingObject를 통해 전역 객체에 키로 등록하고 함수 객체를 즉시 할당한다.
            - 하지만 함수 호이스팅은 함수 객체를 바로 할당하기 때문에 선언문 이전에 함수를 undefined가 아니라 정상 호출할 수 있다.(변수 호이스팅과의 차이)
        - 선언적 환경 레코드 생성
          - let과 const 키워드로 선언한 변수는 전역 객체에 할당되지 않고 선언적 환경에 \<uninitialized> 상태로 등록된다.
          - 따라서, 변수 호이스팅이 발생하지만 선언 단계와 초기화 단계가 분리되어 진행되므로 TDZ(일시적 사각지대)에 빠지게 된어 참조할 수 없는 상태다.
    - this 바인딩 
      - 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩 된다.
  - (2-3) 외부 렉시컬 환경에 대한 참조 결정
    - 외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 상위 스코프를 가리키므로 null이 할당된다.
    - 왜냐하면, 전역 코드를 포함하는 소스 코드는 없기 때문이다. => 전역 렉시컬 환경이 스코프 체인의 종점에 존재함을 의미함.
- (3) 전역 코드 실행
  - 변수 할당문이 실행되어 전역 변수에 값이 할당된다.
  - 동일한 이름의 식별자가 다른 스코프에 여러개 존재할 수 있으므로 식별자 결정을 진행한다. 식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작함.
- (4) 함수 코드 평가
  - 전역 코드 실행 시 함수를 호출하게 되면 전역 코드의 실행을 일시 중단하고 해당 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드 평가가 진행됨.
    - 함수 실행 컨텍스트 생성
    - 함수 렉시컬 환경 생성 
      - 함수 환경 레코드 생성: 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩함수를 등록하고 관리.
      - this 바인딩: 함수 환경 레코드의 [[thisValue]] 내부 슬롯에 this가 바인딩된다. 이때 함수 호출방식에 따라 this가 결정되는데, 일반 함수는 전역 객체가 바인딩된다.
      - 외부 렉시컬 환경에 대한 참조 결정: 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.
        - 전역 코드(전역 실행 컨텍스트)가 실행 중에 함수 평가가 진행되면 전역 실행 컨텍스트의 렉시컬 환경을 참조하게 된다.
        - 자바스크립트 엔진은 함수 객체의 내부슬롯 [[Environment]]에 함수의 상위 스코프를 저장함.
        - 결과적으로 외부 렉시컬 환경에 대한 참조에 할당되는 것은 상위 스코프 함수 객체 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조이다.
- (5) 함수 코드 실행
  - 변수 할당문이 실행되어 해당 변수에 값이 할당된다.
  - 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색한다. 
    - 만약 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자를 검색한다.
  - 함수 코드 실행 중 내부 함수가 존재하여 호출하게 되면 해당되는 내부함수로 코드의 제어권이 이동하여 이전에 진행했던 (4)과 (5)과정을 동일하게 진행한다.
- (6) 함수 코드 실행 종료
  - 모든 내부 함수까지 평가와 실행이 끝나면, 가장 내부의 함수부터 코드 실행이 종료되고 실행 컨텍스트가 실행 컨텍스트 스택(콜스택)에서 제거된다.
  - 하지만, 렉시컬 환경은 (실행 컨텍스트에 참조되지만) 독립적인 객체이므로 바로 소멸하지 않고 모든 참조가 사라질 때 가비지 컬렉터에 의해 메모리 공간 확보 해제 후 소멸한다.
- (7) 전역 코드 실행 종료
  - 더이상 실행 전역 코드가 없으면 전역 코드 실행이 종료되고 전역 실행 컨택스트도 POP되어 실행 컨텍스트 스택에는 아무것도 남지 않는다.

## ◇ 참고링크
- 도서: 모던 자바스크립트 Deep Dive, 자바스크립트의 기본 개념과 동작 원리
