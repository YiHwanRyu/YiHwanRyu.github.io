---
layout: single
title:  "TIL038: 동시성 문제의 해결과정"
categories: [TIL]
tag: [InnovationCamp, TIL, SpringBoot, Jpa, Mysql] 
toc: true
toc_sticky: true
toc_label: 목차
toc_icon: "fas fa-mug-hot"
author_profile: false
search: true
use_math: true
published: true
sidebar:
    nav: "counts"
---

# [부제: 동시다발적인 신청과정에서 발생하는 동시성 문제를 해결하기]
Today I Learned, 2023/08/22

## ◆ 문제상황
- 최종프로젝트(수강신청 사이트)의 부하테스트 진행 중 다음과 같은 문제들이 발생하였다.
  - 약 4000명이 동시에 신청할 때 신청제한인원 보다 많은 인원이 신청테이블에 생겨난 상황
  - 장바구니 신청의 일반부하 테스트 중 데드락이 발생한 상황
- 위의 문제해결과정을 정리하면서 관련된 개념을 살펴보려고 한다.

## ◆ 내용정리

### 동시성 문제?
- 문제가 발생한 이후에 가장 먼저 검색한 키워드였다.
- 동일한 데이터에 대하여 여러 Thread 또는 세션이 제어를 시도할 때 발생하는 문제
- 즉, 하나의 데이터를 여러 사용자가 동시에 수정하면서 데이터의 값이 다르게 읽히거나 수정되는 문제를 말하는 것이었다.

### Mysql의 InnoDB, MVCC, Isolation level
- 현재 프로젝트에서는 DB로 Mysql을 사용 중이다.
  - Mysql은 5.5버전 이후에 기본적으로 스토리지 엔진에 InnoDB가 적용되어 있는데, InnoDB를 통한 MVCC가 이미 관여하고 있다. 
  - 즉, MVCC에 의한 동시성 제어가 이미 이루어지고 있다.
- 그렇다면 MVCC는 뭘까?
  - MVCC(Multi-Version Concurrency Control)는 다중 버전에 의하여 동시성을 제어하는 것으로 Snapshot을 만들어내어 각각의 트랜젝션을 일관되게 관리하는 것을 말한다.
- 오.. 그러면 InnoDB에서 어떻게 동시성을 관리하고 있던 걸까?
  - Isolation level은 기본적으로 REPEATABLE READ를 따르고 있다.(READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 중에서 3단계)
  - 각각의 단계별로 만들어 질 수 있는 오류가 있는데 REPEATABLE READ에서는 보통의 경우 PHANTOM READ라는 오류가 발생한다.
    - 하지만 Mysql은 Next-Key Lock(Record Lock + Gap Lock)으로 이 문제도 해결하고 있다고 한다. 
  - 거의 대부분의 문제를 해결하고 있는 Mysql... 도대체 문제가 왜 발생한 걸까? 

### Write Skew
- Repeatable Read의 격리 레벨에서 발생하는 문제 중 하나로 다른 트랜젝션이 서로 다른 객체에 write하는 경우 발생하는 문제
  - 현재 수강신청 로직 중 일부는 다음과 같다.
    - 강의 테이블을 조회하여 강의 엔티티의 수강제한 인원과 강의 엔티티의 현재 신청인원을 가져와 비교한다.
    - 신청인원이 수강제한인원보다 적으면 수강신청 테이블에 강의ID, 학생ID를 추가한다.(UPDATE)
    - 이후 강의 엔티티의 신청인원을 증가시키고, 학생 엔티티의 신청학점을 증가시킨다.
  - 여기서 A, B학생이 있을때, 같은 강의를 동시에 신청한다면 A의 강의 신청 트랜잭션이 진행 중일 때, 아직 강의 엔티티의 신청인원이 늘어난 것이 아니기 때문에 B학생도 강의를 신청 가능하다. 따라서 A와 B모두 수강제한 인원을 초과하더라도 수강신청 테이블에 추가되는 일이 발생한다.

### 해결방법1: SERIALIZABLE로 Isolation level을 올리기
- 트랜젝션 진행 중 모든 접근을 차단함.
- 확실한 격리를 통한 정합성이 보장되나 성능이 매우 떨어지고, 데드락이 쉽게 발생하므로 대부분의 현업에서 사용하지 않는 것으로 알고 있음. 

### 해결방법2: Locking Read
- 배타락(exclusive lock)의 사용: 비관적 락(pessimistic lock)의 일종으로 공유락(read 허용)과 다르게 트랜잭션이 완료될 때까지 read와 write를 모두 차단.
- 단, 동시성 문제가 발생한 로직에 부분적으로 사용해야함. 성능 이슈가 발생할 우려가 있다.
- 결국에 현재 발생한 Write Skew 문제와 데드락 이슈를 동시에 해결하면서도 성능면에서 상대적으로 효율적인 방법이다. 따라서 배타락을 통한 Locking Read를 적용하기로 하였다.

### JPA에 적용하기
- 다음과 같이 적용하여 배타락을 사용할 수 있다.
- 다만, timeout을 설정하기 어려운 이슈가 있고 분산서버를 사용한다면 분산락을 이용해야 한다.
  - 현재 프로젝트에서는 스케일아웃을 하게된다면, 카프카의 주키퍼를 통한 분산락을 구현할 예정

```java
public interface CourseRepository extends JpaRepository<Course, Long> {
  
  @Lock(LockModeType.PESSIMISTIC_WRITE)
  @Query("SELECT c FROM Course c WHERE c.id = :courseId")
	Optional<Course> findCourseByIdAndLock(Long courseId);

}
```

## ◇ 참고링크
- [https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)
- [https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)
- [https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)
- [https://fisache.tistory.com/24](https://fisache.tistory.com/24)
- [https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/](https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/)
